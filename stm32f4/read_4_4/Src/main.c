/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void delay(void)
{
	for(uint32_t i=0;i<300000;i++);

}


int main(void)
{
    /* Loop forever */
	uint32_t volatile * const pClkEnReg = (uint32_t *)(0x40023800 + 0x30);
	//enable clock

	uint32_t volatile * const pModeReg = (uint32_t *) (0x40020C00);
	//enable mode register

	uint32_t volatile * const pdoutput = (uint32_t *)(0x40020C00+0x14);
	//output register

	uint32_t volatile * const pinput = (uint32_t *)(0x40020C00+0x10);
	//input register

	uint32_t volatile * const pudreg = (uint32_t *)(0x40020C00+0x0C);
	//pull up down register


	//1. enable clock for gpiod peripheral clock
	 *pClkEnReg |= (1<<3);

	//2. configure pd0,pd1,pd2,pd3 as output (rows)
	*pModeReg &= ~(0xFF << 0);
	*pModeReg |= (0x55);

	//3. configure pd8,pd9,pd10 as input (columns)
	*pModeReg &= ~(0x3F << 16);

	//4. enable internal pull up reg & pull down reg
	*pudreg &= ~(0xFF << 16);
	*pudreg |= (0x15 << 16);
while(1){

	//make all rows high
	*pdoutput |= 0x0F;

	//make r1 low(pd0)
	*pdoutput &= ~( 1 << 0);

	//scan all columns
	//scan c1 pd8 is zero or not
	if(!(*pinput & (1<<8))){
		delay();
		printf("1 pressed\n");
	}

	//check if c2 pd9 is pressed
	if(!(*pinput & (1<<9))){
			delay();
			printf("2 pressed\n");
	}

	//check if c3 is pressed
	if(!(*pinput & (1<<10))){
				delay();
				printf("3 pressed\n");
	}



	//make all rows high
		*pdoutput |= 0x0F;
//
//		//make r2 low(pd0)
		*pdoutput &= ~( 1 << 1);
//
//		//scan all columns
		//scan c1 pd8 is zero or not
		if(!(*pinput & (1<<8))){
			delay();
			printf("4 pressed\n");
		}

		//check if c2 pd9 is pressed
		if(!(*pinput & (1<<9))){
				delay();
				printf("5 pressed\n");
		}

		//check if c3 is pressed
		if(!(*pinput & (1<<10))){
					delay();
					printf("6 pressed\n");
		}




		//make all rows high
			*pdoutput |= 0x0F;

			//make r3 low(pd0)
			*pdoutput &= ~( 1 << 2);

			//scan all columns
			//scan c1 pd8 is zero or not
			if(!(*pinput & (1<<8))){
				delay();
				printf("7 pressed\n");
			}

			//check if c2 pd9 is pressed
			if(!(*pinput & (1<<9))){
					delay();
					printf("8 pressed\n");
			}

			//check if c3 is pressed
			if(!(*pinput & (1<<10))){
						delay();
						printf("9 pressed\n");
			}



			//make all rows high
						*pdoutput |= 0x0F;

						//make r3 low(pd0)
						*pdoutput &= ~( 1 << 3);

						//scan all columns
						//scan c1 pd8 is zero or not
						if(!(*pinput & (1<<8))){
							delay();
							printf("* pressed\n");
						}

						//check if c2 pd9 is pressed
						if(!(*pinput & (1<<9))){
								delay();
								printf("0 pressed\n");
						}

						//check if c3 is pressed
						if(!(*pinput & (1<<10))){
									delay();
									printf("# pressed\n");
						}

}
//	for(;;);
}
